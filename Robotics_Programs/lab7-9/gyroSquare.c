#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//function signatures
int get_distance(int distance);
void drive(int distance, int speed);
void Angle_rotation();
void drive_in_square(int distance);


task main()
{
	//initializing distance to be 0
	int dist = 0;
	
	//calling get_distance() function
	displayCenteredBigTextLine(1, "distance is: %d", get_distance(dist));
	sleep(200);

}


//funtion to get the distance robot will drive
int get_distance(int distance)
{	
	//as long the enter botton not pressed 
	while (getButtonPress(buttonEnter)  == 0)
	{
		//if user presses the up button distance set to 80
		if (getButtonPress(buttonUp))
		{
			distance = 80;	
			displayCenteredBigTextLine(1, "buttons up");
			drive_in_square(distance);     //calling funtion with distance of 80 as argument 
		}
		//else if user presses the down button distance set to 60
		else if (getButtonPress(buttonDown))
		{
			distance = 60;
			displayCenteredBigTextLine(1, "buttons down");
			drive_in_square(distance);    //calling funtion with distance of 60 as argument
		}
		//else if user presses the left button distance set to 20
		else if (getButtonPress(buttonLeft))
		{
			distance = 20;
			displayCenteredBigTextLine(1, "buttons left");
			drive_in_square(distance);    //calling funtion with distance of 20 as argument 
		}
		//else if user presses the right button distance set to 40
		else if (getButtonPress(buttonRight))
		{
			distance = 40;
			displayCenteredBigTextLine(1, "buttons right");
			drive_in_square(distance);    //calling funtion with distance of 40 as argument 
		}
	}//end while loop
	 
	
	return distance;
}


//function to drive with 2 parameters
void drive(int distance, int speed)
{
	float wheel_rotations= (distance/15)*360;
	
	setMotorSyncEncoder(leftMotor, rightMotor, 0,wheel_rotations, speed);
	waitUntilMotorStop(leftMotor);
	
			
}


//function to turn an angle of 90 degrees
void Angle_rotation()
{
	int Angle;
	
	eraseDisplay(); // Clear the display
	displayCenteredTextLine(2,"gyro resetting");
	SensorType[S2] = sensorEV3_Gyro; // set sensor to port 2
	sleep(500);
	resetGyro(S2); //reset Gyro to get to 0 degrees
	sleep(3);
	displayCenteredTextLine(2,"Angle =%d",getGyroDegrees(S2));
	sleep(500);
	
	
	// Turn Robot 90 degrees around, then stop:
	eraseDisplay();
	Angle=getGyroDegrees(S2); // Get the starting angle which should be 0
	displayCenteredTextLine(2,"Angle =%d",Angle);
	
	setMotorSync(leftMotor, rightMotor, -100, 10); //start motor to 
	displayCenteredTextLine(4,"rotating 90");
	
	while (abs(Angle) < 86)
	{
		sleep(2);
		Angle=getGyroDegrees(S2);
		displayCenteredBigTextLine(5,"current angle %4d",Angle);
		
	}
	setMotorSync(leftMotor, rightMotor, 0, 0); // stop the motors
	sleep(500);
	
}


//function that drives in a square
void drive_in_square(int distance)
{
	drive(distance, 20); //calling drive function to drive straight
	Angle_rotation(); //calling function to turn 90 degrees
	drive(distance, 20);
	Angle_rotation();
	drive(distance, 20);
	Angle_rotation();
	drive(distance, 20);
	Angle_rotation();
	
}