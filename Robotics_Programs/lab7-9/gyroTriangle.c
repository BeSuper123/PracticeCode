#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// function assignments
int get_distance(int distance);
void drive(int distance, int speed);
void Angle_rotation();
void drive_in_triangle(int distance);


task main()
{
	int dist = 0;
	
	
	// displays what the current distance is
	displayCenteredBigTextLine(1, "distance is: %d", get_distance(dist));
	sleep(200);

}


// chooses what the distance is depending on what number is pressed
int get_distance(int distance)
{	
	// loops while no button is entered
	while (getButtonPress(buttonEnter)  == 0)
	{
		// sets the distance to 80 and displays the up button
		if (getButtonPress(buttonUp))
		{
			distance = 80;	
			displayCenteredBigTextLine(1, "buttons up");
			drive_in_triangle(distance);
		}
		
		// sets the distance to 60 and displays the down button
		else if (getButtonPress(buttonDown))
		{
			distance = 60;
			displayCenteredBigTextLine(1, "buttons down");
			drive_in_triangle(distance);
		}
		
		// sets the distance to 10 and displays the left button
		else if (getButtonPress(buttonLeft))
		{
			distance = 20;
			displayCenteredBigTextLine(1, "buttons left");
			drive_in_triangle(distance);
		}
		
		// sets the distance to 40 and displays the right button
		else if (getButtonPress(buttonRight))
		{
			distance = 40;
			displayCenteredBigTextLine(1, "buttons right");
			drive_in_triangle(distance);
		}
	}
	 
	// returns what the new distance is set to
	return distance;
}

// moves the robot forward using the speed and distance given
void drive(int distance, int speed)
{
	float wheel_rotations= (distance/15)*360;
	
	setMotorSyncEncoder(leftMotor, rightMotor, 0,wheel_rotations, speed);
	waitUntilMotorStop(leftMotor);
	
			
}

// sets the angle rotation to triangle angle (60 Degrees)
void Angle_rotation()
{
	int Angle;
	
	
	eraseDisplay(); // Clear the display
	displayCenteredTextLine(2,"gyro resetting"); // displays that the gyros are resetting
	SensorType[S2] = sensorEV3_Gyro; // set sensor to port 2
	sleep(500);
	resetGyro(S2);// resets gyros
	sleep(3);
	displayCenteredTextLine(2,"Angle =%d",getGyroDegrees(S2)); // displays what the current angle is
	sleep(500);
	
	
	// Turn Robot 90 degrees around, then stop:
	eraseDisplay();
	Angle=getGyroDegrees(S2); // Get the starting angle which should be 0
	displayCenteredTextLine(2,"Angle =%d",Angle);
	
	//rotates the robot 60 Degrees
	setMotorSync(leftMotor, rightMotor, -100, 10);
	displayCenteredTextLine(4,"rotating 60");
	
	// loops while the angle is not up to 60 Degrees
	while (abs(Angle) < 115)
	{
		sleep(2);
		Angle=getGyroDegrees(S2); // the angle is set to what the gyro is currently
		displayCenteredBigTextLine(5,"current angle %4d",Angle);
		
	}
	
	// stop the motors
	setMotorSync(leftMotor, rightMotor, 0, 0); 
	sleep(500);
	
}

// calls the methods to help turn the robot in a triangle format
void drive_in_triangle(int distance)
{
	drive(distance, 20); // calling drive function to drive straight
	Angle_rotation(); // calling function to turn 90 degrees
	drive(distance, 20);
	Angle_rotation();
	drive(distance, 20);
	Angle_rotation();
	
}